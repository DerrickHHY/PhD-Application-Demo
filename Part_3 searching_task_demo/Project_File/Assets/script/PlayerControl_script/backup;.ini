using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

public class GameInput : MonoBehaviour
{

    public event EventHandler OnInteractAction; // 这部分也就是为了让其他代码来订阅的event， player里面的订阅的就是这个（例如gameInput.OnInteractAction +=）
    public event EventHandler<MouseInteractEventArgs> OnMouseInteractAction; //<>内的内容是通过PlayerAnimator.cs额外设置的一个事件信息传递方式
    private PlayerInputActions playerInputActions; //激活input system 相关代码的 step1 
    private bool waitingForFirstPanelClick = false;
    private bool isInputBlocked = true;
    [Header("UI Panels")]
    public GameObject uiPanel1; // 第一个UI面板
    public GameObject uiPanel2; // 第二个UI面板

    [Header("UI Timing")]
    public float introDuration = 5f; // 前5秒UI轮流时间
    public float panelDisplayTime = 2.5f; // 每个面板显示时间（可调整）
    private void Start()
    {
        Debug.Log("Starting GameInput: UIControler and SceneTimer");
        StartCoroutine(UIControler());
    }

    private void Awake()                               //激活input system 相关代码的 step2 
    {
        playerInputActions = new PlayerInputActions(); //激活input system 相关代码的 step2 
        playerInputActions.Player.Enable(); //激活input system 相关代码的 step3 启用对应的控制组件 可视化界面的中的第一列 action map 部分playerInputActions.Player.Disable() 就可以禁用
        playerInputActions.Player.Interact.performed += Interact_performed;

        //左边的interact的案件激活的话， 右侧的订阅者活动就会激活
        playerInputActions.Player.Interact.performed += ClickInteraction; //点击左键后开始传输信息
        if (uiPanel1 != null) uiPanel1.SetActive(false);
        if (uiPanel2 != null) uiPanel2.SetActive(false);
    }

    private void ClickInteraction(InputAction.CallbackContext context)
    {
        if (!isInputBlocked)
        {
            Vector2 screenPosition = playerInputActions.Player.MouseClick.ReadValue<Vector2>();
            OnMouseInteractAction?.Invoke(this, new MouseInteractEventArgs
            {
                ScreenPosition = screenPosition
            });
        }
    }
    private void OnDestroy()
    {
        // 清理事件订阅 // 这部分的逻辑是什么 原本只有click interaction, 后续根据gork的建议有吧其他的订阅加购上了

        playerInputActions.Player.Interact.performed -= Interact_performed;
        playerInputActions.Player.MouseClick.performed -= ClickInteraction;
        playerInputActions.Dispose();
    }

    private void Interact_performed(InputAction.CallbackContext obj) //订阅者的激活是什么呢？如下//另外在gork中的建议这里不是obj是context, 这两个有什么区别？？
    {
        if (!isInputBlocked)
        {
            OnInteractAction?.Invoke(this, EventArgs.Empty);
                    //为了方便理解 可以看以下代码，是等效的
                    // if (OnInteractAction != null)//这个是在检测是否有其他的script订阅了这个代码，而不是在赋值，比喻为：名为OnInteractAction的电视台是否有观众
                    // {
                    //     OnInteractAction(this, EventArgs.Empty);
                    //                     //发送者是this, 这个发送者传递的是空的参数
                    // }
        }

    }
    public Vector2 GetMovementVectorNormalized()
    {
        if (isInputBlocked)
        {
            return Vector2.zero; // 阻止输入时返回零向量
        }
        Vector2 inputVector = playerInputActions.Player.Move.ReadValue<Vector2>();
        return inputVector.normalized;
    }
    public Vector2 GetMousVector() //视角移动 https://www.youtube.com/watch?v=uPlXdMKM5pc
    {

        //newCameraRotation.x += playerCameraSetting.ViewYSensitivity * rawViewInput.y * Time.deltaTime;
        // newCameraRotation = cameraholder.localRotation.eulerAngles;
        // cameraholder.localRotation = Quaternion.Euler(newCameraRotation);
        if (isInputBlocked)
        {
            return Vector2.zero; // 阻止输入时返回零向量
        }
        Vector2 rawViewInput = playerInputActions.Player.View.ReadValue<Vector2>();
        return rawViewInput;
    }

    IEnumerator UIControler()
        {
            isInputBlocked = true;
            // 前5秒：轮流显示UI面板
            float elapsed = 0f;
            bool showPanel1 = true; // 从Panel1开始

            while (elapsed < introDuration)
            {
                if (showPanel1)
                {
                    uiPanel1.SetActive(true);
                    uiPanel2.SetActive(false);
                }
                else
                {
                    uiPanel1.SetActive(false);
                    uiPanel2.SetActive(true);
                }

                yield return new WaitForSecondsRealtime(panelDisplayTime); // 显示当前面板2.5秒
                elapsed += panelDisplayTime;
                showPanel1 = !showPanel1; // 切换面板
            }

            // 隐藏所有UI面板
            uiPanel1.SetActive(false);
            uiPanel2.SetActive(false);
            isInputBlocked = false;
           
        }

}


-----------------------第二版本
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

public class GameInput : MonoBehaviour
{

    public event EventHandler OnInteractAction; // 这部分也就是为了让其他代码来订阅的event， player里面的订阅的就是这个（例如gameInput.OnInteractAction +=）
    public event EventHandler<MouseInteractEventArgs> OnMouseInteractAction; //<>内的内容是通过PlayerAnimator.cs额外设置的一个事件信息传递方式
    private PlayerInputActions playerInputActions; //激活input system 相关代码的 step1 
    private bool waitingForFirstPanelClick = false;
    private bool isInputBlocked = true;
    [Header("UI Panels")]
    public GameObject uiPanel1; // 第一个UI面板
    public GameObject uiPanel2; // 第二个UI面板

    [Header("UI Timing")]
    public float introDuration = 5f; // 前5秒UI轮流时间
    public float panelDisplayTime = 2.5f; // 每个面板显示时间（可调整）
    private float totalTime = 50f;
    private void Awake()                               //激活input system 相关代码的 step2 
    {
        playerInputActions = new PlayerInputActions(); //激活input system 相关代码的 step2 
        playerInputActions.Player.Enable(); //激活input system 相关代码的 step3 启用对应的控制组件 可视化界面的中的第一列 action map 部分playerInputActions.Player.Disable() 就可以禁用
        playerInputActions.Player.Interact.performed += Interact_performed;//左边的interact的案件激活的话， 右侧的订阅者活动就会激活
        playerInputActions.Player.MouseClick.performed += ClickInteraction; //点击左键后开始传输信息

        if (uiPanel1 != null) uiPanel1.SetActive(false);
        if (uiPanel2 != null) uiPanel2.SetActive(false);
    }
    private void Start()
    {
        if (uiPanel1 != null)
        {
            uiPanel1.SetActive(true);
            waitingForFirstPanelClick = true;
            Debug.Log("First panel displayed, waiting for UIInteraction click...");
        }
        else
        {
            Debug.LogError("uiPanel1 is not assigned!");
        }
        // 验证 uiPanel1 是否有 Button 组件
        if (uiPanel1 != null && uiPanel1.GetComponent<UnityEngine.UI.Button>() == null)
        {
            Debug.LogWarning("uiPanel1 does not have a Button component! Please add one.");
        }
    }

    private void OnDestroy()
    {
        // 清理事件订阅 // 这部分的逻辑是什么 原本只有click interaction, 后续根据gork的建议有吧其他的订阅加购上了

        playerInputActions.Player.Interact.performed -= Interact_performed;
        playerInputActions.Player.MouseClick.performed -= ClickInteraction;
        playerInputActions.Dispose();
    }

    private void ClickInteraction(InputAction.CallbackContext context)
    {
        if (!isInputBlocked)
        {
            Vector2 screenPosition = playerInputActions.Player.MouseClick.ReadValue<Vector2>();
            OnMouseInteractAction?.Invoke(this, new MouseInteractEventArgs
            {
                ScreenPosition = screenPosition
            });
        }
    }

    private void Interact_performed(InputAction.CallbackContext obj) //订阅者的激活是什么呢？如下//另外在gork中的建议这里不是obj是context, 这两个有什么区别？？
    {
        if (!isInputBlocked)
        {
            OnInteractAction?.Invoke(this, EventArgs.Empty);
            //为了方便理解 可以看以下代码，是等效的
            // if (OnInteractAction != null)//这个是在检测是否有其他的script订阅了这个代码，而不是在赋值，比喻为：名为OnInteractAction的电视台是否有观众
            // {
            //     OnInteractAction(this, EventArgs.Empty);
            //                     //发送者是this, 这个发送者传递的是空的参数
            // }
        }

    }

    public Vector2 GetMovementVectorNormalized()
    {
        if (isInputBlocked)
        {
            return Vector2.zero; // 阻止输入时返回零向量
        }
        Vector2 inputVector = playerInputActions.Player.Move.ReadValue<Vector2>();
        return inputVector.normalized;
    }
    public Vector2 GetMousVector() //视角移动 https://www.youtube.com/watch?v=uPlXdMKM5pc
    {

        //newCameraRotation.x += playerCameraSetting.ViewYSensitivity * rawViewInput.y * Time.deltaTime;
        // newCameraRotation = cameraholder.localRotation.eulerAngles;
        // cameraholder.localRotation = Quaternion.Euler(newCameraRotation);
        if (isInputBlocked)
        {
            return Vector2.zero; // 阻止输入时返回零向量
        }
        Vector2 rawViewInput = playerInputActions.Player.View.ReadValue<Vector2>();
        return rawViewInput;
    }
    public void OnUIPanel1Clicked()
    {
        if (waitingForFirstPanelClick)
        {
            waitingForFirstPanelClick = false;
            if (uiPanel1 != null) uiPanel1.SetActive(false);
            Debug.Log("uiPanel1 Button clicked! Starting UI switching and timer...");

            // 启动后续 UI 切换协程（从点击开始）
            StartCoroutine(UIControler());

            // 启动场景计时器（从点击开始，总 50 秒）
            StartCoroutine(SceneTimer());
        }
    }
    IEnumerator UIControler()
    {
        isInputBlocked = true;
        // 前5秒：轮流显示UI面板
        float elapsed = 0f;
        
        if (uiPanel2 != null) uiPanel2.SetActive(true);
        yield return new WaitForSecondsRealtime(panelDisplayTime);
        elapsed += panelDisplayTime;
        // bool showPanel1 = true; // 从Panel1开始
        // while (elapsed < introDuration)
        // {
        //     if (showPanel1)
        //     {
        //         uiPanel1.SetActive(true);
        //         uiPanel2.SetActive(false);
        //     }
        //     else
        //     {
        //         uiPanel1.SetActive(false);
        //         uiPanel2.SetActive(true);
        //     }

        //     yield return new WaitForSecondsRealtime(panelDisplayTime); // 显示当前面板2.5秒
        //     elapsed += panelDisplayTime;
        //     showPanel1 = !showPanel1; // 切换面板
        // }

        // 隐藏所有UI面板
        uiPanel1.SetActive(false);
        uiPanel2.SetActive(false);
        isInputBlocked = false;

    }
    IEnumerator SceneTimer()
    {
        Debug.Log("SceneTimer started from UIInteraction click, waiting for " + totalTime + " seconds");
        yield return new WaitForSecondsRealtime(totalTime);
        Debug.Log("SceneTimer finished, quitting");
        #if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
        #else
        Application.Quit();
        #endif
    }

}
